---
title: "MFA 20222 Pre-programme Assignment"
author: "Edgar Pon"
date: "27/08/2021"
output:
  html_document:
    theme: flatly
    highlight: zenburn
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

```{r load-libraries, warning=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)  # Load ggplot2, dplyr, and all the other tidyverse packages
library(gapminder)  # gapminder dataset
library(here)
#install.packages(janitor)
library(janitor)
```

# My Biography
My name is _Edgar Pon_ and I’m from Lisbon and Macao. I have completed my bachelor’s degree in **Economics** last year and I lived in _Portugal_, _Macao_ and _France_. I like a good balance between studying and partying and I enjoy having a good time, going out sometimes, having dinner and going to the pub. 
I am fluent in: 

* Portuguese
* Cantonese
* Mandarin 

In my free time, I enjoy watching (any kind of sports) and playing football, chess and board games. 

To find out more about me, this is [Linkedin](linkedin.com/in/edgar-pon) and my profile picture. ![Pic](https://media-exp1.licdn.com/dms/image/C4D03AQFLkCKLyGoqbw/profile-displayphoto-shrink_800_800/0/1542934443933?e=1636588800&v=beta&t=TqI9xebjuK0c-ncg6i7Q53I8fScwKGrPFharvWMkHug).    

# Task 2: `gapminder` country comparison

In this analysis, I have the `gapminder` dataset that has data on life expectancy, population, and GDP per capita for 142 countries from 1952 to 2007. To get a better look, I used glimpse function to see the variable names, variable types, etc., 
I also want to have a look at the first 20 rows of data.

```{r}
glimpse(gapminder)

head(gapminder, 20) # look at the first 20 rows of the dataframe

```

I have created the `country_data`for Portugal and `continent_data` for Europe with the code below.

```{r}
country_data <- gapminder %>% 
            filter(country == "Portugal") 

continent_data <- gapminder %>% 
            filter(continent == "Europe")
```

First, I plot life expectancy over the years for Portugal.

```{r, lifeExp_one_country}
plot1 <- ggplot(data = country_data, mapping = aes(x = year, y = lifeExp))+
geom_point() +
geom_smooth(se = FALSE)+
NULL 

plot1
```

And use `labs()` function to add an informative title to the plot.

```{r, lifeExp_one_country_with_label}
plot1<- plot1 +
labs(title = "Portugal Life Expectancy",
x = "Year",
y = "Life Expectancy") +
NULL


plot1
```

Next, I produce the plot for the european continent.

```{r lifeExp_one_continent}
ggplot(data=continent_data, mapping = aes(x = year , y = lifeExp , colour= country, group =country))+
geom_point() + 
geom_smooth(se = FALSE) +
NULL
```

Finally, I create graphs for all the continents and plot the life expectancy over time.

```{r lifeExp_facet_by_continent}
ggplot(data = gapminder , mapping = aes(x = year , y = lifeExp , colour= continent))+
geom_point() + 
geom_smooth(se = FALSE) +
facet_wrap(~continent) +
theme(legend.position="none") + #remove all legends
NULL
```

After a thorough analysis, I came to the following conclusion.

> Type your answer after this blockquote.

These graphs can be related to the evolution of demographic transition. One of the implications is that as economies develop and overall life quality improves, life expectancy tends to increase. All continents witnessed an increase in life expectancy, albeit at different growth rates and different age structures. Starting with the oceania and european continents, the most developed continents, the average life expectancy is the highest when compared to the other 3 continents. This result is expected due to improvements in healthcare and technology occurring in industrialized countries first. Moreover, in american and asian continents, a similar pattern is observable. However, as most of the countries in these two continents were not yet developed, the growth rate in life expectancy is expected to be higher than the rate in the already developed countries. Lastly, the african continent is the last continent to start the process of industrialization, but when compared to other continents, the growth rate of life expectancy seems to have stagnated in recent years, largely due to political failures, famine and lack of resources to improve living conditions. 

# Task 3: Brexit vote analysis

I will have a look at the results of the 2016 Brexit vote in the UK. First, I read the data using `read_csv()` and have a quick glimpse at the data

```{r load_brexit_data, warning=FALSE, message=FALSE}
brexit_results <- read_csv(here::here("data","brexit_results.csv"))


glimpse(brexit_results)
```

The data comes from [Elliott Morris](https://www.thecrosstab.com/), who cleaned it and made it available through his [DataCamp class on analysing election and polling data in R](https://www.datacamp.com/courses/analyzing-election-and-polling-data-in-r).

My main outcome variable (or y) is `leave_share`, which is the percent of votes cast in favour of Brexit, or leaving the EU. Each row is a UK [parliament constituency](https://en.wikipedia.org/wiki/United_Kingdom_Parliament_constituencies).

To get a sense of the spread, or distribution, of the data, I plot a histogram, a density plot, and the empirical cumulative distribution function of the leave % in all constituencies.

```{r brexit_histogram, warning=FALSE, message=FALSE}

# histogram
ggplot(brexit_results, aes(x = leave_share)) +
  geom_histogram(binwidth = 2.5)+
  labs(title = "Brexit Results", subtitle = "Histogram Distribution" ,caption = "Source:Elliot Morris")+
  xlab ("Born in UK") +
  ylab ("Frequency")+
NULL

# density plot-- think smoothed histogram
ggplot(brexit_results, aes(x = leave_share)) +
  geom_density()+
  labs(title = "Brexit Results",subtitle = "Density Plot",
x = "Leave Share",
y = "Frequency") +
NULL


# The empirical cumulative distribution function (ECDF) 
ggplot(brexit_results, aes(x = leave_share)) +
  stat_ecdf(geom = "step", pad = FALSE) +
  scale_y_continuous(labels = scales::percent)+
  labs(title = "Brexit Results",subtitle = "Cumulative Distribution Plot",
x = "Leave Share",
y = "Frequency") +
NULL
  


```

One common explanation for the Brexit outcome was fear of immigration and opposition to the EU's more open border policy. I check the relationship (or correlation) between the proportion of native born residents (`born_in_uk`) in a constituency and its `leave_share`.

```{r brexit_immigration_correlation}
brexit_results %>% 
  select(leave_share, born_in_uk) %>% 
  cor()
```

The correlation is almost 0.5, which shows that the two variables are positively correlated.

I also create a scatterplot between these two variables using `geom_point` and add the best fit line, using `geom_smooth(method = "lm")`.

```{r brexit_immigration_plot}
plot2<-ggplot(brexit_results, aes(x = born_in_uk, y = leave_share)) +
  geom_point(alpha=0.3) +
  
  # add a smoothing line, and use method="lm" to get the best straight-line
  geom_smooth(method = "lm") + 
  
  # use a white background and frame the plot with a black box
  theme_bw() +
  labs(title = "Brexit Immigration",subtitle = "Scatter Plot",
x = "Born in UK share",
y = "Leave Share") +
NULL

plot2
```


In this section, I came to the following conclusion.

> Type your answer after, and outside, this blockquote.

The scatter plot confirms that there is a positive relationship between UK-born residents in a constituency and voting to leave the EU. There is a cluster of data in the top right corner, hinting at a strong correlation between the two variables. However, some of the data is dispersed so it is not enough to prove causality. This is, some parliamentary constituencies, with either larger or smaller proportions of UK-born residents can vote ambiguously. An interesting study research should be used to analyze in which these parties are situated to have a better understanding of whether location influences the vote. 


# Task 4: Animal rescue incidents attended by the London Fire Brigade

[The London Fire Brigade](https://data.london.gov.uk/dataset/animal-rescue-incidents-attended-by-lfb) attends a range of non-fire incidents (which we call 'special services'). These 'special services' include assistance to animals that may be trapped or in distress. The data is provided from January 2009 and is updated monthly. A range of information is supplied for each incident including some location information (postcode, borough, ward), as well as the data/time of the incidents. We do not routinely record data about animal deaths or injuries.

Please note that any cost included is a notional cost calculated based on the length of time rounded up to the nearest hour spent by Pump, Aerial and FRU appliances at the incident and charged at the current Brigade hourly rate.

```{r load_animal_rescue_data, warning=FALSE, message=FALSE}

url <- "https://data.london.gov.uk/download/animal-rescue-incidents-attended-by-lfb/8a7d91c2-9aec-4bde-937a-3998f4717cd8/Animal%20Rescue%20incidents%20attended%20by%20LFB%20from%20Jan%202009.csv"

animal_rescue <- read_csv(url,
                          locale = locale(encoding = "CP1252")) %>% 
  janitor::clean_names()


glimpse(animal_rescue)
```
One of the more useful things one can do with any data set is quick counts, namely to see how many observations fall within one category. For instance, if I wanted to count the number of incidents by year, I would either use `group_by()... summarise()` or, simply [`count()`](https://dplyr.tidyverse.org/reference/count.html)

```{r, instances_by_calendar_year}

animal_rescue %>% 
  dplyr::group_by(cal_year) %>% 
  summarise(count=n())

animal_rescue %>% 
  count(cal_year, name="count")

```

Let me try to see how many incidents we have by animal group. Again, I do this either using group_by() and summarise(), or by using count()

```{r, animal_group_percentages}
animal_rescue %>% 
  group_by(animal_group_parent) %>% 
  
  #group_by and summarise will produce a new column with the count in each animal group
  summarise(count = n()) %>% 
  
  # mutate adds a new column; here we calculate the percentage
  mutate(percent = round(100*count/sum(count),2)) %>% 
  
  # arrange() sorts the data by percent. Since the default sorting is min to max and we would like to see it sorted
  # in descending order (max to min), we use arrange(desc()) 
  arrange(desc(percent))


animal_rescue %>% 
  
  #count does the same thing as group_by and summarise
  # name = "count" will call the column with the counts "count" ( exciting, I know)
  # and 'sort=TRUE' will sort them from max to min
  count(animal_group_parent, name="count", sort=TRUE) %>% 
  mutate(percent = round(100*count/sum(count),2))


```

Do you see anything strange in these tables? 

Normally, I would expect cats and dogs to be the top 2 animals to have incidents as they are often associated with these events. One would expect that cats would be at the top due to their agility. However, I was not expecting to observe birds have a higher count of incidents than dogs.

Finally, let us have a loot at the notional cost for rescuing each of these animals. As the LFB says,

> Please note that any cost included is a notional cost calculated based on the length of time rounded up to the nearest hour spent by Pump, Aerial and FRU appliances at the incident and charged at the current Brigade hourly rate.

There is two things I will do:

1. Calculate the mean and median `incident_notional_cost` for each `animal_group_parent`
2. Plot a boxplot to get a feel for the distribution of `incident_notional_cost` by `animal_group_parent`.


Before I go on, however, I need to fix `incident_notional_cost` as it is stored as a `chr`, or character, rather than a number.

```{r, parse_incident_cost,message=FALSE, warning=FALSE}

# what type is variable incident_notional_cost from dataframe `animal_rescue`
typeof(animal_rescue$incident_notional_cost)

# readr::parse_number() will convert any numerical values stored as characters into numbers
animal_rescue <- animal_rescue %>% 

  # we use mutate() to use the parse_number() function and overwrite the same variable
  mutate(incident_notional_cost = parse_number(incident_notional_cost))

# incident_notional_cost from dataframe `animal_rescue` is now 'double' or numeric
typeof(animal_rescue$incident_notional_cost)

```

Now tht incident_notional_cost is numeric, I calculate summary statistics for each animal group. 


```{r, stats_on_incident_cost,message=FALSE, warning=FALSE}

animal_rescue %>% 
  
  # group by animal_group_parent
  group_by(animal_group_parent) %>% 
  
  # filter resulting data, so each group has at least 6 observations
  filter(n()>6) %>% 
  
  # summarise() will collapse all values into 3 values: the mean, median, and count  
  # we use na.rm=TRUE to make sure we remove any NAs, or cases where we do not have the incident cos
  summarise(mean_incident_cost = mean (incident_notional_cost, na.rm=TRUE),
            median_incident_cost = median (incident_notional_cost, na.rm=TRUE),
            sd_incident_cost = sd (incident_notional_cost, na.rm=TRUE),
            min_incident_cost = min (incident_notional_cost, na.rm=TRUE),
            max_incident_cost = max (incident_notional_cost, na.rm=TRUE),
            count = n()) %>% 
  
  # sort the resulting data in descending order. You choose whether to sort by count or mean cost.
  arrange(desc(mean_incident_cost))

```



In the section below, I show what I found interesting in the analysis of this data.

The average cost seems to be higher than the median cost for most animals, meaning that there are some large costs(outliers) incurred in specific situations as confirmed with the maximum cost column. One specific intriguing fact is that the highest cost incurred belongs to the cat group, which one would usually not expect.

Finally, I plot the distribution of incident_cost for each animal group.

```{r, plots_on_incident_cost_by_animal_group,message=FALSE, warning=FALSE}

# base_plot
base_plot <- animal_rescue %>% 
  group_by(animal_group_parent) %>% 
  filter(n()>6) %>% 
  ggplot(aes(x=incident_notional_cost))+
  facet_wrap(~animal_group_parent, scales = "free")+
  theme_bw()

base_plot + geom_histogram()
base_plot + geom_density()
base_plot + geom_boxplot()
base_plot + stat_ecdf(geom = "step", pad = FALSE) +
  scale_y_continuous(labels = scales::percent)


```


In the section below, I show what I found in the analysis of this data.

The boxplot best illustrates the variability of the data set because the data distribution is visible across the plot and the outliers of each animal group.
Horses are the group with higher average costs than the rest of the animals, followed by cows and deers. One would typically assume the bigger the animal, the higher the difficulty (time, equipment, labor) to rescue them, thus a higher cost incurred. The personnel may have less experience dealing with larger animals, thus resulting in a longer period to successfully rescue a larger animal. This is observable through the distribution of animals of larger size. Smaller animals tend to be easier to rescue, therefore costs are substantially lower. As cats, birds and dogs have so many recurrent incidents, the fire brigade personnel already have the experience to deal with similar situations and in general, they should be of less complexity, which is the reason why most of the cases are within the quartiles and a small range.

# Submit the assignment

Knit the completed R Markdown file as an HTML document (use the "Knit" button at the top of the script editor window) and upload it to Canvas.

## Details

If you want to, please answer the following

-   Who did you collaborate with: Michael Huang MiM2022
-   Approximately how much time did you spend on this problem set: Datacamp courses around 6 hours, this assignment around 4-5 hours.
-   What, if anything, gave you the most trouble: My laptop does not knit the file in HTML. Have to manually write the Knit function.
rmarkdown::render("Edgar_Pon.rmd")
